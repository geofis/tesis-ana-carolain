---
title: "Posprocesamiento de líneas de costa creadas en Earth Engine"
author: "Ana Valera, Carolain Pérez, Yulisa Arias, José Martínez (tali)"
date: '2023-02-16'
output:
  pdf_document
  # github_document
editor_options: 
  chunk_output_type: console
  keep_tex: true
  pandoc_args: ["--pdf-engine=xelatex"]
header-includes:
  - \usepackage{geometry}
  - \geometry{landscape=true, margin=1in}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = F, message = F, warning = F, fig.width = 11, fig.height = 8)
```

# Representar líneas de costa, transectos, EPR

## Cargar paquetes y funciones


```{r}
library(tidyverse)
library(coastr)
library(sf)
library(lubridate)
library(RColorBrewer)
library(zoo)
library(kableExtra)
options(knitr.kable.NA = '')
my_kable_style <- function(df, caption = '', full_width = T) {
  df %>% kable(format = 'latex', escape = F, booktabs = T,
               digits = 2, caption = caption) %>%
    kable_styling(bootstrap_options = c("hover", "condensed"),
                  latex_options = "HOLD_position",
                  full_width = full_width, position = "center")
}
# Función para clasificar las partes de los transectos en mar o tierra respecto de referencia
devtools::source_url('https://raw.githubusercontent.com/geofis/RCoastSat/master/R/classify-transects.R')
# Función para calcular la distancia de cada línea de costa respecto de la de referencia sobre cada transecto
devtools::source_url('https://raw.githubusercontent.com/geofis/RCoastSat/master/R/extract-points-distances.R')
# Función para suavizar el relleno de los gráficos de series temporales
devtools::source_url('https://raw.githubusercontent.com/geofis/RCoastSat/master/R/interpolate.R')
# La línea siguiente fija el tamaño de los gráficos a unas proporciones "razonables". Editar a conveniencia
## Función para series temporales, tasas de erosión/acreción
calcular_tasa_de_cambio <- function(distancias = distances, transecto,
                                    metodo_descomposicion_loess = T, plot = F) {
  # Paquetes
  library(zoo)
  library(lubridate)
  # Datos
  df_selec <- distancias[distancias$transect==transecto, c('date', 'distance_sign')]
  todas_las_fechas <- data.frame(date = seq(min(df_selec$date), max(df_selec$date), by = "day"))
  df_completo <- merge(todas_las_fechas, df_selec, all.x = T)
  serie_regular <- zoo(df_completo$distance_sign, df_completo$date)
  
  # Rellenado de la serie usando medias móviles
  serie_rellena <- na.approx(serie_regular, na.rm = F)
  # Serie clase ts
  serie_rellena_ts <- ts(data = as.vector(serie_rellena), frequency = 365.25,
                         start = c(year(min(df_selec$date)), yday(min(df_selec$date))))
  
  if(metodo_descomposicion_loess) {
    # Obtención de la tendencia por descomposición de la serie mediante LOESS, y obtención tasa de cambio  (-erosión, +acreción)
    descomposicion <- stl(serie_rellena_ts, 'periodic', na.action = na.trim)
    if(plot) plot(descomposicion)
    tendencia_por_dia <- zoo(as.matrix(descomposicion$time.series[,'trend']), todas_las_fechas$date)
    tendencia_por_mes <- aggregate(tendencia_por_dia, as.yearmon, tail, 1)
    tasa_de_cambio_por_mes <- diff(tendencia_por_mes)
    tasa_de_cambio_por_mes
    tendencia_por_ano <- aggregate(tendencia_por_dia, function(x) year(floor(as.yearmon(x))), tail, 1)
    tasa_de_cambio_por_ano <- diff(tendencia_por_ano)
    tasa_de_cambio_por_ano
    tasa_de_cambio_anual <- mean(tasa_de_cambio_por_ano, na.rm = T)
    tasa_de_cambio_anual }
  else {
    # Obtención de la tendencia por descomposición de la serie mediante medias móviles, y obtención tasa de cambio  (-erosión, +acreción)
    descomposicion <- decompose(serie_rellena_ts)
    if(plot) plot(descomposicion)
    tasa_de_cambio_por_dia <- diff(descomposicion$trend)
    tendencia_por_dia <- zoo(descomposicion$trend, todas_las_fechas[-1, ])
    tendencia_por_mes <- aggregate(tendencia_por_dia, as.yearmon, tail, 1)
    tasa_de_cambio_por_mes <- diff(tendencia_por_mes)
    tasa_de_cambio_por_mes
    tendencia_por_ano <- aggregate(tendencia_por_dia, function(x) year(floor(as.yearmon(x))), tail, 1)
    tasa_de_cambio_por_ano <- diff(tendencia_por_ano)
    tasa_de_cambio_por_ano
    tasa_de_cambio_anual <- mean(tasa_de_cambio_por_ano, na.rm = T)
    tasa_de_cambio_anual
  }
  return(
    list(
      `Periodo y tasa de cambio anual` = data.frame(
        `Periodo` = paste0(year(min(todas_las_fechas$date)),
                          '-',
                          year(max(todas_las_fechas$date)),
                          ' (',
                          year(max(todas_las_fechas$date)) - year(min(todas_las_fechas$date)),
                          ' años)'), 
                 `Tasa de cambio anual, en metros (-erosión,+acreción)` = tasa_de_cambio_anual,
        check.names = F),
      `Tasa de cambio por año, en metros (-erosión,+acreción)` = tasa_de_cambio_por_ano))
}
generar_tabla_de_tasas_de_cambio <- function(tasas_de_cambio, titulo, csv = F) {
  df <- as.data.frame(t(sapply(tasas_de_cambio, function(x) x[[c(1)]]))) %>% 
    mutate(across(starts_with('Tasa'), as.numeric)) %>% 
    rownames_to_column('Transecto')
  if(!csv) {
    df_kable <- df %>%
      my_kable_style(caption = titulo,
                     full_width = F) %>%
      column_spec(column = 3, width = "15em")
    print(df_kable)
  }
  invisible(return(df))
}
generar_tabla_de_tasas_de_cambio_por_ano <- function(tasas_de_cambio, titulo, csv = F) {
  df <- sapply(names(tasas_de_cambio), function(x) {
    data.frame(
      foo = tasas_de_cambio[[x]][2]$`Tasa de cambio por año, en metros (-erosión,+acreción)`,
      check.names = F) %>% 
      rownames_to_column('Año') %>%
      setNames(c('Año', x))
  }, simplify = F) %>% plyr::join_all()
  if(!csv) {
    df_kable <- df %>% 
      my_kable_style(caption = titulo,
                     full_width = T)
    print(df_kable)
  }
  return(df)
}
```

## Pre-2009

### Tramo Este

- Cargar líneas de costa

```{r}
lineas <- st_read('lineas-de-costa/PalenqueNizaoPC_L5_output_lines.gpkg') %>%
  filter(grepl('palenque', tramo, ignore.case = T)) %>%
  st_cast('LINESTRING')
st_geometry(lineas) <- "geometry"
lineas$longitud <- units::drop_units(st_length(lineas))
lineas <- lineas[lineas$longitud > 0, ]
```

- Representar las líneas de costa

```{r}
lineas$intervalo_en_dias <- round(as.numeric(interval(lineas$date, max(lineas$date)), 'days'), 0)
escala_color <- 'BrBG'
mapa_lineas <- lineas %>% ggplot + aes(color=intervalo_en_dias) + geom_sf() +
  theme_minimal() +
  theme(text = element_text(size = 18)) +
  scale_color_gradientn(colors = rev(RColorBrewer::brewer.pal(11, escala_color)))
mapa_lineas
```

- Crear transectos respecto de línea de costa de referencia y representarlos


```{r}
# Umbral de longitud para líneas que podrían usarse como referencia
umbral_longitud <- 1000

# Elegir una línea de referencia
linea_ref <- lineas %>% filter(longitud > umbral_longitud) %>% filter(date == min(date))

# Crear transectos
transectos <- create_transect(x = linea_ref, 200, reverse = T) %>% rename(transect=coastr_id)

# Mapa
mapa_lineas + geom_sf(data = transectos, color = 'blue')
```

- Clasificar las distintas partes del transecto en tierra o mar

```{r}
transectos_clasif <- transclas(tr = transectos, rl = linea_ref)
cols <- colorRampPalette(brewer.pal(9,'Set1'))(nrow(lineas))
ggplot() +
  geom_sf(data = lineas %>% mutate(date = factor(date)), color = cols) +
  geom_sf(
    data = linea_ref %>% mutate(linetype = paste0('Ref. (', date, ')')),
    aes(color=linetype), linewidth = 2, show.legend = 'line') +
  geom_sf(
    data = transectos_clasif %>% mutate(sealand=paste0('Transect: ', sealand)),
    aes(color = sealand), show.legend = 'line', linewidth = 4) +
  scale_color_manual(values = c('black', 'orange', 'blue')) +
  geom_sf_text(
    data = transectos_clasif %>% filter(sealand=='landward') %>%
      st_centroid, aes(label = transect), size = 8) +
  theme_minimal() +
  theme(legend.title = element_blank(), text = element_text(size = 18))
```

- Calcular distancias de cada línea de costa respecto de la línea de referencia

```{r}
distl <- pointdist(sh = lineas, re = linea_ref, tr = transectos_clasif, rtr = transectos)
```

- Generar las series temporales de distancia de la línea de costa respecto a la de referencia

```{r}
interdist <- map(distl, interpolate) %>% plyr::ldply() %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances <- plyr::ldply(distl) %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances %>% 
  ggplot() + theme_bw() + aes(x = date, y = distance_sign) +
  geom_ribbon(data = interdist, aes(ymax = pmax(distance_sign, 0), ymin = 0), fill = "sienna3") +
  geom_ribbon(data = interdist, aes(ymin = pmin(distance_sign, 0), ymax = 0), fill = "skyblue3") +
  geom_hline(yintercept = 0, color = 'grey') +
  geom_line(colour='black', lwd = 0.5) +
  scale_x_date(date_labels = "%Y", date_breaks = '1 year') +
#   scale_y_continuous(limits = c(-30, 30)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5), text = element_text(size = 14)) +
  facet_wrap(~transect, ncol = 2)
```

- Revisión de seguridad: determinar si hay transectos que corten dos veces una misma línea de costa

```{r}
test <- sapply(unique(distances$transect), function(x) {
    conteo_cortes <- table(distances[distances$transect==x, 'date', drop=T])
    mas_de_1 <- length(which(conteo_cortes>1))>0
    ifelse(mas_de_1,
          paste('El transecto', x, 'corta', conteo_cortes[which(conteo_cortes>1)],
                 'veces la línea de costa de fecha', names(conteo_cortes[which(conteo_cortes>1)])),
          paste('El transecto', x, 'pasa la prueba'))
})
test
```

- Tasas de cambio (-erosión, +acreción)

```{r, results='asis'}
tasas_de_cambio <- lapply(
  unique(distances$transect),
  function (x) calcular_tasa_de_cambio(transecto = x)) %>% 
  setNames(paste('Transecto', unique(distances$transect)))
invisible(tasas_de_cambio %>% 
  generar_tabla_de_tasas_de_cambio(titulo = 'Tasa de cambio anual promediada pre-2009 para transectos del Tramo Este'))
invisible(tasas_de_cambio %>%
  generar_tabla_de_tasas_de_cambio_por_ano(
    titulo = 'Tasa de cambio por año pre-2009 (en metros; -erosión, +acreción) para transectos del Tramo Este'))
```

Exportar las tablas anteriores a CSV.

```{r}
tasas_de_cambio %>% 
  generar_tabla_de_tasas_de_cambio(csv = T) %>%
  write_csv('tasas_de_cambio_anual_promediada_pre_2009_por_transecto_tramo_este.csv')
tasas_de_cambio %>%
  generar_tabla_de_tasas_de_cambio_por_ano(csv = T) %>% 
  write_csv('tasas_de_cambio_anual_pre_2009_por_transecto_tramo_este.csv')
```

- Suavizado de la serie con media móvil

```{r}
ventana_de_promediado <- 3 #Número de observaciones para obtener la media movil (ventana de promediado)
distl_med <- sapply(unique(distances$transect),
       function(x){
           df <- distances[distances$transect==x, ]
           df <- df[order(df$date), ]
           x <- zoo(df$distance_sign, df$date)
           mm <- as.numeric(rollmean(x, ventana_de_promediado, fill = NA))
           df$distance_sign <- mm
           df <- df #%>% slice(1:(n()-1))
           return(df)
       }, simplify=F)
interdist_med <- map(distl_med, interpolate) %>% plyr::ldply() %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances_med <- plyr::ldply(distl_med) %>% mutate(date = as.Date(date, "%Y-%m-%d"))
```

- Representación de la serie suavizada

```{r}
distances_med %>% 
  ggplot() + theme_bw() + aes(x = date, y = distance_sign) +
  geom_ribbon(data = interdist_med, aes(ymax = pmax(distance_sign, 0), ymin = 0), fill = "sienna3") +
  geom_ribbon(data = interdist_med, aes(ymin = pmin(distance_sign, 0), ymax = 0), fill = "skyblue3") +
  geom_hline(yintercept = 0, color = 'grey') +
  geom_line(colour='black', lwd = 0.5) +
  scale_x_date(date_labels = "%Y", date_breaks = '1 year') +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5), text = element_text(size = 14)) +
  facet_wrap(~transect, ncol = 2)
```

### Tramo Oeste

> Nota: el suavizado, para este tramo, no funciona adecuadamente.

- Cargar líneas de costa

```{r}
lineas <- st_read('lineas-de-costa/PalenqueNizaoPC_L5_output_lines.gpkg') %>%
  filter(grepl('nizao', tramo, ignore.case = T)) %>%
  st_cast('LINESTRING')
st_geometry(lineas) <- "geometry"
lineas$longitud <- units::drop_units(st_length(lineas))
lineas <- lineas[lineas$longitud > 0, ]
```

- Representar las líneas de costa

```{r}
lineas$intervalo_en_dias <- round(as.numeric(interval(lineas$date, max(lineas$date)), 'days'), 0)
escala_color <- 'BrBG'
mapa_lineas <- lineas %>% ggplot + aes(color=intervalo_en_dias) + geom_sf() +
  theme_minimal() +
  theme(text = element_text(size = 18)) +
  scale_color_gradientn(colors = rev(RColorBrewer::brewer.pal(11, escala_color)))
mapa_lineas
```

- Crear transectos respecto de línea de costa de referencia y representarlos


```{r}
# Umbral de longitud para líneas que podrían usarse como referencia
umbral_longitud <- 1000

# Elegir una línea de referencia
linea_ref <- lineas %>% filter(longitud > umbral_longitud) %>% filter(date == min(date))

# Crear transectos
transectos <- create_transect(x = linea_ref, 500, reverse = T) %>% rename(transect=coastr_id)

# Mapa
mapa_lineas + geom_sf(data = transectos, color = 'blue')
```

- Clasificar las distintas partes del transecto en tierra o mar

```{r}
transectos_clasif <- transclas(tr = transectos, rl = linea_ref)
cols <- colorRampPalette(brewer.pal(9,'Set1'))(nrow(lineas))
ggplot() +
  geom_sf(data = lineas %>% mutate(date = factor(date)), color = cols) +
  geom_sf(
    data = linea_ref %>% mutate(linetype = paste0('Ref. (', date, ')')),
    aes(color=linetype), linewidth = 2, show.legend = 'line') +
  geom_sf(
    data = transectos_clasif %>% mutate(sealand=paste0('Transect: ', sealand)),
    aes(color = sealand), show.legend = 'line', linewidth = 4) +
  scale_color_manual(values = c('black', 'orange', 'blue')) +
  geom_sf_text(
    data = transectos_clasif %>% filter(sealand=='landward') %>%
      st_centroid, aes(label = transect), size = 8) +
  theme_minimal() +
  theme(legend.title = element_blank(), text = element_text(size = 18))
```

- Calcular distancias de cada línea de costa respecto de la línea de referencia

```{r}
distl <- pointdist(sh = lineas, re = linea_ref, tr = transectos_clasif, rtr = transectos)
```

- Generar las series temporales de distancia de la línea de costa respecto a la de referencia

```{r}
interdist <- map(distl, interpolate) %>% plyr::ldply() %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances <- plyr::ldply(distl) %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances %>% 
  ggplot() + theme_bw() + aes(x = date, y = distance_sign) +
  geom_ribbon(data = interdist, aes(ymax = pmax(distance_sign, 0), ymin = 0), fill = "sienna3") +
  geom_ribbon(data = interdist, aes(ymin = pmin(distance_sign, 0), ymax = 0), fill = "skyblue3") +
  geom_hline(yintercept = 0, color = 'grey') +
  geom_line(colour='black', lwd = 0.5) +
  scale_x_date(date_labels = "%Y", date_breaks = '1 year') +
#   scale_y_continuous(limits = c(-30, 30)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5), text = element_text(size = 14)) +
  facet_wrap(~transect, ncol = 2)
```

- Revisión de seguridad: determinar si hay transectos que corten dos veces una misma línea de costa

```{r}
test <- sapply(unique(distances$transect), function(x) {
    conteo_cortes <- table(distances[distances$transect==x, 'date', drop=T])
    mas_de_1 <- length(which(conteo_cortes>1))>0
    ifelse(mas_de_1,
          paste('El transecto', x, 'corta', conteo_cortes[which(conteo_cortes>1)],
                 'veces la línea de costa de fecha', names(conteo_cortes[which(conteo_cortes>1)])),
          paste('El transecto', x, 'pasa la prueba'))
})
test
```

- Tasas de cambio (-erosión, +acreción)

```{r, results='asis'}
tasas_de_cambio <- lapply(
  unique(distances$transect),
  function (x) calcular_tasa_de_cambio(transecto = x)) %>% 
  setNames(paste('Transecto', unique(distances$transect)))
invisible(tasas_de_cambio %>% 
  generar_tabla_de_tasas_de_cambio(titulo = 'Tasa de cambio anual promediada pre-2009 para transectos del Tramo Oeste'))
invisible(tasas_de_cambio %>%
  generar_tabla_de_tasas_de_cambio_por_ano(
    titulo = 'Tasa de cambio por año pre-2009 (en metros; -erosión, +acreción) para transectos del Tramo Oeste'))
```

Exportar las tablas anteriores a CSV.

```{r}
tasas_de_cambio %>% 
  generar_tabla_de_tasas_de_cambio(csv = T) %>%
  write_csv('tasas_de_cambio_anual_promediada_pre_2009_por_transecto_tramo_oeste.csv')
tasas_de_cambio %>%
  generar_tabla_de_tasas_de_cambio_por_ano(csv = T) %>% 
  write_csv('tasas_de_cambio_anual_pre_2009_por_transecto_tramo_oeste.csv')
```

- Suavizado de la serie con media móvil

```{r}
ventana_de_promediado <- 1 #Número de observaciones para obtener la media movil (ventana de promediado)
distl_med <- sapply(unique(distances$transect),
       function(x){
           df <- distances[distances$transect==x, ]
           df <- df[order(df$date), ]
           x <- zoo(df$distance_sign, df$date)
           mm <- as.numeric(rollmean(x, ventana_de_promediado, fill = NA))
           df$distance_sign <- mm
           df <- df #%>% slice(1:(n()-1))
           return(df)
       }, simplify=F)
interdist_med <- map(distl_med, interpolate) %>% plyr::ldply() %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances_med <- plyr::ldply(distl_med) %>% mutate(date = as.Date(date, "%Y-%m-%d"))
```

- Representación de la serie suavizada

```{r}
distances_med %>% 
  ggplot() + theme_bw() + aes(x = date, y = distance_sign) +
  geom_ribbon(data = interdist_med, aes(ymax = pmax(distance_sign, 0), ymin = 0), fill = "sienna3") +
  geom_ribbon(data = interdist_med, aes(ymin = pmin(distance_sign, 0), ymax = 0), fill = "skyblue3") +
  geom_hline(yintercept = 0, color = 'grey') +
  geom_line(colour='black', lwd = 0.5) +
  scale_x_date(date_labels = "%Y", date_breaks = '1 year') +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5), text = element_text(size = 14)) +
  facet_wrap(~transect, ncol = 2)
```

- Cálculo de EPR (*end point rates*)

```{r, eval=F}
calcular_epr <- function(fecha_ref = '2013-06-16', fecha_ini = '2013-06-16', fecha_fin = '2015-04-19',
                         campo_trans = 'transect', trans = 1, campo_fecha = 'date',
                         tabla_dist = distances, campo_dist = 'distance_sign'){
    d_trans <- tabla_dist[tabla_dist[, campo_trans] == trans, ]
    selector_fecha <- d_trans[, campo_fecha, drop = T]
#     selector_trans <- d_trans[, campo_trans, drop = T]
    T <- as.numeric(as.Date(fecha_fin, "%Y-%m-%d") - as.Date(fecha_ini, "%Y-%m-%d"))
    d0 <- tryCatch(as.numeric(d_trans[fecha_ini == selector_fecha, campo_dist, drop = T]))
    d1 <- tryCatch(as.numeric(d_trans[fecha_fin == selector_fecha, campo_dist, drop = T]))
    D <- tryCatch(d1 - d0)
    EPR <- (D/T)*365
    return(EPR)
}
# EPR anual, periodo 1, 2013-06-16 y 2015-04-19
periodo_1 <- c('2013-06-16', '2015-04-19')
epr_periodo_1 <- data.frame(col = sapply(
    paste('Transecto', (1:15)),
    function(x) calcular_epr(trans = as.integer(gsub('Transecto ', '', x))),
    simplify = T)) %>% setNames(paste('EPR anual, periodo 1, desde', periodo_1[1], 'a', periodo_1[2]))
epr_periodo_1

# EPR anual, periodo 2, 2015-04-19 y 2021-01-29
periodo_2 <- c('2015-04-19', '2021-01-29')
epr_periodo_2 <- data.frame(col = sapply(
    paste('Transecto', (1:15)),
    function(x)
        calcular_epr(
            trans = as.integer(gsub('Transecto ', '', x)),
        fecha_ini = periodo_2[1], fecha_fin = periodo_2[2]),
    simplify = T)) %>% setNames(paste('EPR anual, periodo 2, desde', periodo_2[1], 'a', periodo_2[2]))
epr_periodo_2

# EPR anual, periodo 3, 2021-01-29 y 2021-12-15
periodo_3 <- c('2021-01-29', '2021-12-15')
epr_periodo_3 <- data.frame(col = sapply(
    paste('Transecto', (1:15)),
    function(x)
        calcular_epr(
            trans = as.integer(gsub('Transecto ', '', x)),
        fecha_ini = periodo_3[1], fecha_fin = periodo_3[2]),
    simplify = T)) %>% setNames(paste('EPR anual, periodo 2, desde', periodo_3[1], 'a', periodo_3[2]))
epr_periodo_3
```

## Pos-2013 (Landsat 8)

### Tramo Palenque Este

- Cargar líneas de costa

```{r}
lineas <- st_read('lineas-de-costa/PalenqueNizaoPC_L8_output_lines.gpkg') %>%
  filter(grepl('palenque este', tramo, ignore.case = T)) %>%
  st_cast('LINESTRING')
st_geometry(lineas) <- "geometry"
lineas$longitud <- units::drop_units(st_length(lineas))
lineas <- lineas[lineas$longitud > 0, ]
```

- Representar las líneas de costa

```{r}
lineas$intervalo_en_dias <- round(as.numeric(interval(lineas$date, max(lineas$date)), 'days'), 0)
escala_color <- 'BrBG'
mapa_lineas <- lineas %>% ggplot + aes(color=intervalo_en_dias) + geom_sf() +
  theme_minimal() +
  theme(text = element_text(size = 18)) +
  scale_color_gradientn(colors = rev(RColorBrewer::brewer.pal(11, escala_color)))
mapa_lineas
```

- Crear transectos respecto de línea de costa de referencia y representarlos


```{r}
# Umbral de longitud para líneas que podrían usarse como referencia
umbral_longitud <- 100

# Elegir una línea de referencia
linea_ref <- lineas %>% filter(longitud > umbral_longitud) %>% filter(date == min(date, na.rm = T))

# Crear transectos
transectos <- create_transect(x = linea_ref, 100, reverse = T) %>% rename(transect=coastr_id)

# Mapa
mapa_lineas + geom_sf(data = transectos, color = 'blue')
```

- Clasificar las distintas partes del transecto en tierra o mar

```{r}
transectos_clasif <- transclas(tr = transectos, rl = linea_ref)
cols <- colorRampPalette(brewer.pal(9,'Set1'))(nrow(lineas))
ggplot() +
  geom_sf(data = lineas %>% mutate(date = factor(date)), color = cols) +
  geom_sf(
    data = linea_ref %>% mutate(linetype = paste0('Ref. (', date, ')')),
    aes(color=linetype), linewidth = 2, show.legend = 'line') +
  geom_sf(
    data = transectos_clasif %>% mutate(sealand=paste0('Transect: ', sealand)),
    aes(color = sealand), show.legend = 'line', linewidth = 4) +
  scale_color_manual(values = c('black', 'orange', 'blue')) +
  geom_sf_text(
    data = transectos_clasif %>% filter(sealand=='landward') %>%
      st_centroid, aes(label = transect), size = 8) +
  theme_minimal() +
  theme(legend.title = element_blank(), text = element_text(size = 18))
```

- Calcular distancias de cada línea de costa respecto de la línea de referencia

```{r}
distl <- pointdist(sh = lineas, re = linea_ref, tr = transectos_clasif, rtr = transectos)
```

- Generar las series temporales de distancia de la línea de costa respecto a la de referencia

```{r}
interdist <- map(distl, interpolate) %>% plyr::ldply() %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances <- plyr::ldply(distl) %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances %>% 
  ggplot() + theme_bw() + aes(x = date, y = distance_sign) +
  geom_ribbon(data = interdist, aes(ymax = pmax(distance_sign, 0), ymin = 0), fill = "sienna3") +
  geom_ribbon(data = interdist, aes(ymin = pmin(distance_sign, 0), ymax = 0), fill = "skyblue3") +
  geom_hline(yintercept = 0, color = 'grey') +
  geom_line(colour='black', lwd = 0.5) +
  scale_x_date(date_labels = "%Y", date_breaks = '1 year') +
#   scale_y_continuous(limits = c(-30, 30)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5), text = element_text(size = 14)) +
  facet_wrap(~transect, ncol = 2)
```

- Revisión de seguridad: determinar si hay transectos que corten dos veces una misma línea de costa

```{r}
test <- sapply(unique(distances$transect), function(x) {
    conteo_cortes <- table(distances[distances$transect==x, 'date', drop=T])
    mas_de_1 <- length(which(conteo_cortes>1))>0
    ifelse(mas_de_1,
          paste('El transecto', x, 'corta', conteo_cortes[which(conteo_cortes>1)],
                 'veces la línea de costa de fecha', names(conteo_cortes[which(conteo_cortes>1)])),
          paste('El transecto', x, 'pasa la prueba'))
})
test
```

- Tasas de cambio (-erosión, +acreción)

```{r, results='asis'}
tasas_de_cambio <- lapply(
  unique(distances$transect),
  function (x) calcular_tasa_de_cambio(transecto = x)) %>% 
  setNames(paste('Transecto', unique(distances$transect)))
invisible(tasas_de_cambio %>% 
  generar_tabla_de_tasas_de_cambio(titulo = 'Tasa de cambio anual promediada pos-2013 (L8) para transectos del Tramo Palenque Este'))
invisible(tasas_de_cambio %>%
  generar_tabla_de_tasas_de_cambio_por_ano(
    titulo = 'Tasa de cambio por año pos-2013 (en metros; -erosión, +acreción) para transectos del Tramo Palenque Este'))
```

Exportar las tablas anteriores a CSV.

```{r}
tasas_de_cambio %>% 
  generar_tabla_de_tasas_de_cambio(csv = T) %>%
  write_csv('tasas_de_cambio_anual_promediada_pos_2013_por_transecto_tramo_palenque_este.csv')
tasas_de_cambio %>%
  generar_tabla_de_tasas_de_cambio_por_ano(csv = T) %>% 
  write_csv('tasas_de_cambio_anual_pos_2013_por_transecto_tramo_palenque_este.csv')
```

- Suavizado de la serie con media móvil

```{r}
ventana_de_promediado <- 3 #Número de observaciones para obtener la media movil (ventana de promediado)
distl_med <- sapply(unique(distances$transect),
       function(x){
           df <- distances[distances$transect==x, ]
           df <- df[order(df$date), ]
           x <- zoo(df$distance_sign, df$date)
           mm <- as.numeric(rollmean(x, ventana_de_promediado, fill = NA))
           df$distance_sign <- mm
           df <- df #%>% slice(1:(n()-1))
           return(df)
       }, simplify=F)
interdist_med <- map(distl_med, interpolate) %>% plyr::ldply() %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances_med <- plyr::ldply(distl_med) %>% mutate(date = as.Date(date, "%Y-%m-%d"))
```

- Representación de la serie suavizada

```{r}
distances_med %>% 
  ggplot() + theme_bw() + aes(x = date, y = distance_sign) +
  geom_ribbon(data = interdist_med, aes(ymax = pmax(distance_sign, 0), ymin = 0), fill = "sienna3") +
  geom_ribbon(data = interdist_med, aes(ymin = pmin(distance_sign, 0), ymax = 0), fill = "skyblue3") +
  geom_hline(yintercept = 0, color = 'grey') +
  geom_line(colour='black', lwd = 0.5) +
  scale_x_date(date_labels = "%Y", date_breaks = '1 year') +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5), text = element_text(size = 14)) +
  facet_wrap(~transect, ncol = 2)
```

### Tramo Palenque Centro

- Cargar líneas de costa

```{r}
lineas <- st_read('lineas-de-costa/PalenqueNizaoPC_L8_output_lines.gpkg') %>%
  filter(grepl('palenque centro', tramo, ignore.case = T)) %>%
  st_cast('LINESTRING')
st_geometry(lineas) <- "geometry"
lineas$longitud <- units::drop_units(st_length(lineas))
lineas <- lineas[lineas$longitud > 0, ]
```

- Representar las líneas de costa

```{r}
lineas$intervalo_en_dias <- round(as.numeric(interval(lineas$date, max(lineas$date)), 'days'), 0)
escala_color <- 'BrBG'
mapa_lineas <- lineas %>% ggplot + aes(color=intervalo_en_dias) + geom_sf() +
  theme_minimal() +
  theme(text = element_text(size = 18)) +
  scale_color_gradientn(colors = rev(RColorBrewer::brewer.pal(11, escala_color)))
mapa_lineas
```

- Crear transectos respecto de línea de costa de referencia y representarlos


```{r}
# Umbral de longitud para líneas que podrían usarse como referencia
umbral_longitud <- 300

# Elegir una línea de referencia
linea_ref <- lineas %>% filter(longitud > umbral_longitud) %>% filter(date == min(date, na.rm = T))

# Crear transectos
transectos <- create_transect(x = linea_ref, 100, reverse = T) %>% rename(transect=coastr_id)

# Mapa
mapa_lineas + geom_sf(data = transectos, color = 'blue')
```

- Clasificar las distintas partes del transecto en tierra o mar

```{r}
transectos_clasif <- transclas(tr = transectos, rl = linea_ref)
cols <- colorRampPalette(brewer.pal(9,'Set1'))(nrow(lineas))
ggplot() +
  geom_sf(data = lineas %>% mutate(date = factor(date)), color = cols) +
  geom_sf(
    data = linea_ref %>% mutate(linetype = paste0('Ref. (', date, ')')),
    aes(color=linetype), linewidth = 2, show.legend = 'line') +
  geom_sf(
    data = transectos_clasif %>% mutate(sealand=paste0('Transect: ', sealand)),
    aes(color = sealand), show.legend = 'line', linewidth = 4) +
  scale_color_manual(values = c('black', 'orange', 'blue')) +
  geom_sf_text(
    data = transectos_clasif %>% filter(sealand=='landward') %>%
      st_centroid, aes(label = transect), size = 8) +
  theme_minimal() +
  theme(legend.title = element_blank(), text = element_text(size = 18))
```

- Calcular distancias de cada línea de costa respecto de la línea de referencia

```{r}
distl <- pointdist(sh = lineas, re = linea_ref, tr = transectos_clasif, rtr = transectos)
```

- Generar las series temporales de distancia de la línea de costa respecto a la de referencia

```{r}
interdist <- map(distl, interpolate) %>% plyr::ldply() %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances <- plyr::ldply(distl) %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances %>% 
  ggplot() + theme_bw() + aes(x = date, y = distance_sign) +
  geom_ribbon(data = interdist, aes(ymax = pmax(distance_sign, 0), ymin = 0), fill = "sienna3") +
  geom_ribbon(data = interdist, aes(ymin = pmin(distance_sign, 0), ymax = 0), fill = "skyblue3") +
  geom_hline(yintercept = 0, color = 'grey') +
  geom_line(colour='black', lwd = 0.5) +
  scale_x_date(date_labels = "%Y", date_breaks = '1 year') +
#   scale_y_continuous(limits = c(-30, 30)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5), text = element_text(size = 14)) +
  facet_wrap(~transect, ncol = 2)
```

- Revisión de seguridad: determinar si hay transectos que corten dos veces una misma línea de costa

```{r}
test <- sapply(unique(distances$transect), function(x) {
    conteo_cortes <- table(distances[distances$transect==x, 'date', drop=T])
    mas_de_1 <- length(which(conteo_cortes>1))>0
    ifelse(mas_de_1,
          paste('El transecto', x, 'corta', conteo_cortes[which(conteo_cortes>1)],
                 'veces la línea de costa de fecha', names(conteo_cortes[which(conteo_cortes>1)])),
          paste('El transecto', x, 'pasa la prueba'))
})
test
```

- Tasas de cambio (-erosión, +acreción)

```{r, results='asis'}
tasas_de_cambio <- lapply(
  unique(distances$transect),
  function (x) calcular_tasa_de_cambio(transecto = x)) %>% 
  setNames(paste('Transecto', unique(distances$transect)))
invisible(tasas_de_cambio %>% 
  generar_tabla_de_tasas_de_cambio(titulo = 'Tasa de cambio anual promediada pos-2013 (L8) para transectos del Tramo Palenque Centro'))
invisible(tasas_de_cambio %>%
  generar_tabla_de_tasas_de_cambio_por_ano(
    titulo = 'Tasa de cambio por año pos-2013 (en metros; -erosión, +acreción) para transectos del Tramo Palenque Centro'))
```

Exportar las tablas anteriores a CSV.

```{r}
tasas_de_cambio %>% 
  generar_tabla_de_tasas_de_cambio(csv = T) %>%
  write_csv('tasas_de_cambio_anual_promediada_pos_2013_por_transecto_tramo_palenque_centro.csv')
tasas_de_cambio %>%
  generar_tabla_de_tasas_de_cambio_por_ano(csv = T) %>% 
  write_csv('tasas_de_cambio_anual_pos_2013_por_transecto_tramo_palenque_centro.csv')
```

- Suavizado de la serie con media móvil

```{r}
ventana_de_promediado <- 3 #Número de observaciones para obtener la media movil (ventana de promediado)
distl_med <- sapply(unique(distances$transect),
       function(x){
           df <- distances[distances$transect==x, ]
           df <- df[order(df$date), ]
           x <- zoo(df$distance_sign, df$date)
           mm <- as.numeric(rollmean(x, ventana_de_promediado, fill = NA))
           df$distance_sign <- mm
           df <- df #%>% slice(1:(n()-1))
           return(df)
       }, simplify=F)
interdist_med <- map(distl_med, interpolate) %>% plyr::ldply() %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances_med <- plyr::ldply(distl_med) %>% mutate(date = as.Date(date, "%Y-%m-%d"))
```

- Representación de la serie suavizada

```{r}
distances_med %>% 
  ggplot() + theme_bw() + aes(x = date, y = distance_sign) +
  geom_ribbon(data = interdist_med, aes(ymax = pmax(distance_sign, 0), ymin = 0), fill = "sienna3") +
  geom_ribbon(data = interdist_med, aes(ymin = pmin(distance_sign, 0), ymax = 0), fill = "skyblue3") +
  geom_hline(yintercept = 0, color = 'grey') +
  geom_line(colour='black', lwd = 0.5) +
  scale_x_date(date_labels = "%Y", date_breaks = '1 year') +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5), text = element_text(size = 14)) +
  facet_wrap(~transect, ncol = 2)
```

### Tramo Palenque Oeste

- Cargar líneas de costa

```{r}
lineas <- st_read('lineas-de-costa/PalenqueNizaoPC_L8_output_lines.gpkg') %>%
  filter(grepl('palenque oeste', tramo, ignore.case = T)) %>%
  st_cast('LINESTRING')
st_geometry(lineas) <- "geometry"
lineas$longitud <- units::drop_units(st_length(lineas))
lineas <- lineas[lineas$longitud > 0, ]
```

- Representar las líneas de costa

```{r}
lineas$intervalo_en_dias <- round(as.numeric(interval(lineas$date, max(lineas$date)), 'days'), 0)
escala_color <- 'BrBG'
mapa_lineas <- lineas %>% ggplot + aes(color=intervalo_en_dias) + geom_sf() +
  theme_minimal() +
  theme(text = element_text(size = 18)) +
  scale_color_gradientn(colors = rev(RColorBrewer::brewer.pal(11, escala_color)))
mapa_lineas
```

- Crear transectos respecto de línea de costa de referencia y representarlos


```{r}
# Umbral de longitud para líneas que podrían usarse como referencia
umbral_longitud <- 800

# Elegir una línea de referencia
linea_ref <- lineas %>% filter(longitud > umbral_longitud) %>% filter(date == min(date, na.rm = T))

# Crear transectos
transectos <- create_transect(x = linea_ref, 200, reverse = T) %>% rename(transect=coastr_id)

# Mapa
mapa_lineas + geom_sf(data = transectos, color = 'blue')
```

- Clasificar las distintas partes del transecto en tierra o mar

```{r}
transectos_clasif <- transclas(tr = transectos, rl = linea_ref)
cols <- colorRampPalette(brewer.pal(9,'Set1'))(nrow(lineas))
ggplot() +
  geom_sf(data = lineas %>% mutate(date = factor(date)), color = cols) +
  geom_sf(
    data = linea_ref %>% mutate(linetype = paste0('Ref. (', date, ')')),
    aes(color=linetype), linewidth = 2, show.legend = 'line') +
  geom_sf(
    data = transectos_clasif %>% mutate(sealand=paste0('Transect: ', sealand)),
    aes(color = sealand), show.legend = 'line', linewidth = 4) +
  scale_color_manual(values = c('black', 'orange', 'blue')) +
  geom_sf_text(
    data = transectos_clasif %>% filter(sealand=='landward') %>%
      st_centroid, aes(label = transect), size = 8) +
  theme_minimal() +
  theme(legend.title = element_blank(), text = element_text(size = 18))
```

- Calcular distancias de cada línea de costa respecto de la línea de referencia

```{r}
distl <- pointdist(sh = lineas, re = linea_ref, tr = transectos_clasif, rtr = transectos)
```

- Generar las series temporales de distancia de la línea de costa respecto a la de referencia

```{r}
interdist <- map(distl, interpolate) %>% plyr::ldply() %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances <- plyr::ldply(distl) %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances %>% 
  ggplot() + theme_bw() + aes(x = date, y = distance_sign) +
  geom_ribbon(data = interdist, aes(ymax = pmax(distance_sign, 0), ymin = 0), fill = "sienna3") +
  geom_ribbon(data = interdist, aes(ymin = pmin(distance_sign, 0), ymax = 0), fill = "skyblue3") +
  geom_hline(yintercept = 0, color = 'grey') +
  geom_line(colour='black', lwd = 0.5) +
  scale_x_date(date_labels = "%Y", date_breaks = '1 year') +
#   scale_y_continuous(limits = c(-30, 30)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5), text = element_text(size = 14)) +
  facet_wrap(~transect, ncol = 2)
```

- Revisión de seguridad: determinar si hay transectos que corten dos veces una misma línea de costa

```{r}
test <- sapply(unique(distances$transect), function(x) {
    conteo_cortes <- table(distances[distances$transect==x, 'date', drop=T])
    mas_de_1 <- length(which(conteo_cortes>1))>0
    ifelse(mas_de_1,
          paste('El transecto', x, 'corta', conteo_cortes[which(conteo_cortes>1)],
                 'veces la línea de costa de fecha', names(conteo_cortes[which(conteo_cortes>1)])),
          paste('El transecto', x, 'pasa la prueba'))
})
test
```

- Tasas de cambio (-erosión, +acreción)

```{r, results='asis'}
tasas_de_cambio <- lapply(
  unique(distances$transect),
  function (x) calcular_tasa_de_cambio(transecto = x)) %>% 
  setNames(paste('Transecto', unique(distances$transect)))
invisible(tasas_de_cambio %>% 
  generar_tabla_de_tasas_de_cambio(titulo = 'Tasa de cambio anual promediada pos-2013 (L8) para transectos del Tramo Palenque Oeste'))
invisible(tasas_de_cambio %>%
  generar_tabla_de_tasas_de_cambio_por_ano(
    titulo = 'Tasa de cambio por año pos-2013 (en metros; -erosión, +acreción) para transectos del Tramo Palenque Oeste'))
```

Exportar las tablas anteriores a CSV.

```{r}
tasas_de_cambio %>% 
  generar_tabla_de_tasas_de_cambio(csv = T) %>%
  write_csv('tasas_de_cambio_anual_promediada_pos_2013_por_transecto_tramo_palenque_oeste.csv')
tasas_de_cambio %>%
  generar_tabla_de_tasas_de_cambio_por_ano(csv = T) %>% 
  write_csv('tasas_de_cambio_anual_pos_2013_por_transecto_tramo_palenque_oeste.csv')
```

- Suavizado de la serie con media móvil

```{r}
ventana_de_promediado <- 3 #Número de observaciones para obtener la media movil (ventana de promediado)
distl_med <- sapply(unique(distances$transect),
       function(x){
           df <- distances[distances$transect==x, ]
           df <- df[order(df$date), ]
           x <- zoo(df$distance_sign, df$date)
           mm <- as.numeric(rollmean(x, ventana_de_promediado, fill = NA))
           df$distance_sign <- mm
           df <- df #%>% slice(1:(n()-1))
           return(df)
       }, simplify=F)
interdist_med <- map(distl_med, interpolate) %>% plyr::ldply() %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances_med <- plyr::ldply(distl_med) %>% mutate(date = as.Date(date, "%Y-%m-%d"))
```

- Representación de la serie suavizada

```{r}
distances_med %>% 
  ggplot() + theme_bw() + aes(x = date, y = distance_sign) +
  geom_ribbon(data = interdist_med, aes(ymax = pmax(distance_sign, 0), ymin = 0), fill = "sienna3") +
  geom_ribbon(data = interdist_med, aes(ymin = pmin(distance_sign, 0), ymax = 0), fill = "skyblue3") +
  geom_hline(yintercept = 0, color = 'grey') +
  geom_line(colour='black', lwd = 0.5) +
  scale_x_date(date_labels = "%Y", date_breaks = '1 year') +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5), text = element_text(size = 14)) +
  facet_wrap(~transect, ncol = 2)
```

### Tramo Nizao este

- Cargar líneas de costa

```{r}
lineas <- st_read('lineas-de-costa/PalenqueNizaoPC_L8_output_lines.gpkg') %>%
  filter(grepl('nizao este', tramo, ignore.case = T)) %>%
  st_cast('LINESTRING')
st_geometry(lineas) <- "geometry"
lineas$longitud <- units::drop_units(st_length(lineas))
lineas <- lineas[lineas$longitud > 0, ]
```

- Representar las líneas de costa

```{r}
lineas$intervalo_en_dias <- round(as.numeric(interval(lineas$date, max(lineas$date)), 'days'), 0)
escala_color <- 'BrBG'
mapa_lineas <- lineas %>% ggplot + aes(color=intervalo_en_dias) + geom_sf() +
  theme_minimal() +
  theme(text = element_text(size = 18)) +
  scale_color_gradientn(colors = rev(RColorBrewer::brewer.pal(11, escala_color)))
mapa_lineas
```

- Crear transectos respecto de línea de costa de referencia y representarlos


```{r}
# Umbral de longitud para líneas que podrían usarse como referencia
umbral_longitud <- 1000

# Elegir una línea de referencia
linea_ref <- lineas %>% filter(longitud > umbral_longitud) %>% filter(date == "2013-08-03 15:04:35 AST")

# Crear transectos
transectos <- create_transect(x = linea_ref, 400, reverse = T) %>% rename(transect=coastr_id)

# Mapa
mapa_lineas + geom_sf(data = transectos, color = 'blue')
```

- Clasificar las distintas partes del transecto en tierra o mar

```{r}
transectos_clasif <- transclas(tr = transectos, rl = linea_ref)
cols <- colorRampPalette(brewer.pal(9,'Set1'))(nrow(lineas))
ggplot() +
  geom_sf(data = lineas %>% mutate(date = factor(date)), color = cols) +
  geom_sf(
    data = linea_ref %>% mutate(linetype = paste0('Ref. (', date, ')')),
    aes(color=linetype), linewidth = 2, show.legend = 'line') +
  geom_sf(
    data = transectos_clasif %>% mutate(sealand=paste0('Transect: ', sealand)),
    aes(color = sealand), show.legend = 'line', linewidth = 4) +
  scale_color_manual(values = c('black', 'orange', 'blue')) +
  geom_sf_text(
    data = transectos_clasif %>% filter(sealand=='landward') %>%
      st_centroid, aes(label = transect), size = 8) +
  theme_minimal() +
  theme(legend.title = element_blank(), text = element_text(size = 18))
```

- Calcular distancias de cada línea de costa respecto de la línea de referencia

```{r}
distl <- pointdist(sh = lineas, re = linea_ref, tr = transectos_clasif, rtr = transectos)
```

- Generar las series temporales de distancia de la línea de costa respecto a la de referencia

```{r}
interdist <- map(distl, interpolate) %>% plyr::ldply() %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances <- plyr::ldply(distl) %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances %>% 
  ggplot() + theme_bw() + aes(x = date, y = distance_sign) +
  geom_ribbon(data = interdist, aes(ymax = pmax(distance_sign, 0), ymin = 0), fill = "sienna3") +
  geom_ribbon(data = interdist, aes(ymin = pmin(distance_sign, 0), ymax = 0), fill = "skyblue3") +
  geom_hline(yintercept = 0, color = 'grey') +
  geom_line(colour='black', lwd = 0.5) +
  scale_x_date(date_labels = "%Y", date_breaks = '1 year') +
#   scale_y_continuous(limits = c(-30, 30)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5), text = element_text(size = 14)) +
  facet_wrap(~transect, ncol = 2)
```

- Revisión de seguridad: determinar si hay transectos que corten dos veces una misma línea de costa

```{r}
test <- sapply(unique(distances$transect), function(x) {
    conteo_cortes <- table(distances[distances$transect==x, 'date', drop=T])
    mas_de_1 <- length(which(conteo_cortes>1))>0
    ifelse(mas_de_1,
          paste('El transecto', x, 'corta', conteo_cortes[which(conteo_cortes>1)],
                 'veces la línea de costa de fecha', names(conteo_cortes[which(conteo_cortes>1)])),
          paste('El transecto', x, 'pasa la prueba'))
})
test
```

- Tasas de cambio (-erosión, +acreción)

```{r, results='asis'}
tasas_de_cambio <- lapply(
  unique(distances$transect),
  function (x) calcular_tasa_de_cambio(transecto = x)) %>% 
  setNames(paste('Transecto', unique(distances$transect)))
invisible(tasas_de_cambio %>% 
  generar_tabla_de_tasas_de_cambio(titulo = 'Tasa de cambio anual promediada pos-2013 (L8) para transectos del Tramo Nizao Este'))
invisible(tasas_de_cambio %>%
  generar_tabla_de_tasas_de_cambio_por_ano(
    titulo = 'Tasa de cambio por año pos-2013 (en metros; -erosión, +acreción) para transectos del Tramo Nizao Este'))
```

Exportar las tablas anteriores a CSV.

```{r}
tasas_de_cambio %>% 
  generar_tabla_de_tasas_de_cambio(csv = T) %>%
  write_csv('tasas_de_cambio_anual_promediada_pos_2013_por_transecto_tramo_nizao_este.csv')
tasas_de_cambio %>%
  generar_tabla_de_tasas_de_cambio_por_ano(csv = T) %>% 
  write_csv('tasas_de_cambio_anual_pos_2013_por_transecto_tramo_nizao_este.csv')
```

- Suavizado de la serie con media móvil

```{r}
ventana_de_promediado <- 3 #Número de observaciones para obtener la media movil (ventana de promediado)
distl_med <- sapply(unique(distances$transect),
       function(x){
           df <- distances[distances$transect==x, ]
           df <- df[order(df$date), ]
           x <- zoo(df$distance_sign, df$date)
           mm <- as.numeric(rollmean(x, ventana_de_promediado, fill = NA))
           df$distance_sign <- mm
           df <- df #%>% slice(1:(n()-1))
           return(df)
       }, simplify=F)
interdist_med <- map(distl_med, interpolate) %>% plyr::ldply() %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances_med <- plyr::ldply(distl_med) %>% mutate(date = as.Date(date, "%Y-%m-%d"))
```

- Representación de la serie suavizada

```{r}
distances_med %>% 
  ggplot() + theme_bw() + aes(x = date, y = distance_sign) +
  geom_ribbon(data = interdist_med, aes(ymax = pmax(distance_sign, 0), ymin = 0), fill = "sienna3") +
  geom_ribbon(data = interdist_med, aes(ymin = pmin(distance_sign, 0), ymax = 0), fill = "skyblue3") +
  geom_hline(yintercept = 0, color = 'grey') +
  geom_line(colour='black', lwd = 0.5) +
  scale_x_date(date_labels = "%Y", date_breaks = '1 year') +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5), text = element_text(size = 14)) +
  facet_wrap(~transect, ncol = 3)
```

### Tramo Nizao oeste

- Cargar líneas de costa

```{r}
lineas <- st_read('lineas-de-costa/PalenqueNizaoPC_L8_output_lines.gpkg') %>%
  filter(grepl('nizao oeste', tramo, ignore.case = T)) %>%
  st_cast('LINESTRING')
# QUITANDO COSTAS QUE SE CORTAN DOS VECES EN LOS TRANSECTOS,
# LO CUAL SE COMPROBÓ EN LOS TESTS (MÁS ADELANTE)
lineas <- lineas %>%
  mutate(foo = as.character(as.Date(date, '%Y%m%d'))) %>%
  filter(!foo %in% c("2015-10-28", "2021-11-29")) %>%
  select(-foo)
st_geometry(lineas) <- "geometry"
lineas$longitud <- units::drop_units(st_length(lineas))
lineas <- lineas[lineas$longitud > 0, ]
```

- Representar las líneas de costa

```{r}
lineas$intervalo_en_dias <- round(as.numeric(interval(lineas$date, max(lineas$date)), 'days'), 0)
escala_color <- 'BrBG'
mapa_lineas <- lineas %>% ggplot + aes(color=intervalo_en_dias) + geom_sf() +
  theme_minimal() +
  theme(text = element_text(size = 18)) +
  scale_color_gradientn(colors = rev(RColorBrewer::brewer.pal(11, escala_color)))
mapa_lineas
```

- Crear transectos respecto de línea de costa de referencia y representarlos


```{r}
# Umbral de longitud para líneas que podrían usarse como referencia
umbral_longitud <- 200

# Elegir una línea de referencia
linea_ref <- lineas %>% filter(longitud > umbral_longitud) %>% filter(date == "2013-08-03 15:04:35 AST")

# Crear transectos
transectos <- create_transect(x = linea_ref, 50, reverse = T) %>% rename(transect=coastr_id)

# Mapa
mapa_lineas + geom_sf(data = transectos, color = 'blue')
```

- Clasificar las distintas partes del transecto en tierra o mar

```{r}
transectos_clasif <- transclas(tr = transectos, rl = linea_ref)
cols <- colorRampPalette(brewer.pal(9,'Set1'))(nrow(lineas))
ggplot() +
  geom_sf(data = lineas %>% mutate(date = factor(date)), color = cols) +
  geom_sf(
    data = linea_ref %>% mutate(linetype = paste0('Ref. (', date, ')')),
    aes(color=linetype), linewidth = 2, show.legend = 'line') +
  geom_sf(
    data = transectos_clasif %>% mutate(sealand=paste0('Transect: ', sealand)),
    aes(color = sealand), show.legend = 'line', linewidth = 4) +
  scale_color_manual(values = c('black', 'orange', 'blue')) +
  geom_sf_text(
    data = transectos_clasif %>% filter(sealand=='landward') %>%
      st_centroid, aes(label = transect), size = 8) +
  theme_minimal() +
  theme(legend.title = element_blank(), text = element_text(size = 18))
```

- Calcular distancias de cada línea de costa respecto de la línea de referencia

```{r}
distl <- pointdist(sh = lineas, re = linea_ref, tr = transectos_clasif, rtr = transectos)
```

- Generar las series temporales de distancia de la línea de costa respecto a la de referencia

```{r}
interdist <- map(distl, interpolate) %>% plyr::ldply() %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances <- plyr::ldply(distl) %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances %>% 
  ggplot() + theme_bw() + aes(x = date, y = distance_sign) +
  geom_ribbon(data = interdist, aes(ymax = pmax(distance_sign, 0), ymin = 0), fill = "sienna3") +
  geom_ribbon(data = interdist, aes(ymin = pmin(distance_sign, 0), ymax = 0), fill = "skyblue3") +
  geom_hline(yintercept = 0, color = 'grey') +
  geom_line(colour='black', lwd = 0.5) +
  scale_x_date(date_labels = "%Y", date_breaks = '1 year') +
#   scale_y_continuous(limits = c(-30, 30)) +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5), text = element_text(size = 14)) +
  facet_wrap(~transect, ncol = 2)
```

- Revisión de seguridad: determinar si hay transectos que corten dos veces una misma línea de costa

```{r}
test <- sapply(unique(distances$transect), function(x) {
    conteo_cortes <- table(distances[distances$transect==x, 'date', drop=T])
    mas_de_1 <- length(which(conteo_cortes>1))>0
    ifelse(mas_de_1,
          paste('El transecto', x, 'corta', conteo_cortes[which(conteo_cortes>1)],
                 'veces la línea de costa de fecha', names(conteo_cortes[which(conteo_cortes>1)])),
          paste('El transecto', x, 'pasa la prueba'))
})
test
```

- Tasas de cambio (-erosión, +acreción)

```{r, results='asis'}
tasas_de_cambio <- lapply(
  unique(distances$transect),
  function (x) calcular_tasa_de_cambio(transecto = x)) %>% 
  setNames(paste('Transecto', unique(distances$transect)))
invisible(tasas_de_cambio %>% 
  generar_tabla_de_tasas_de_cambio(titulo = 'Tasa de cambio anual promediada pos-2013 (L8) para transectos del Tramo Nizao Oeste'))
invisible(tasas_de_cambio %>%
  generar_tabla_de_tasas_de_cambio_por_ano(
    titulo = 'Tasa de cambio por año pos-2013 (en metros; -erosión, +acreción) para transectos del Tramo Nizao Oeste'))
```

Exportar las tablas anteriores a CSV.

```{r}
tasas_de_cambio %>% 
  generar_tabla_de_tasas_de_cambio(csv = T) %>%
  write_csv('tasas_de_cambio_anual_promediada_pos_2013_por_transecto_tramo_nizao_oeste.csv')
tasas_de_cambio %>%
  generar_tabla_de_tasas_de_cambio_por_ano(csv = T) %>% 
  write_csv('tasas_de_cambio_anual_pos_2013_por_transecto_tramo_nizao_oeste.csv')
```

- Suavizado de la serie con media móvil

```{r}
ventana_de_promediado <- 3 #Número de observaciones para obtener la media movil (ventana de promediado)
distl_med <- sapply(unique(distances$transect),
       function(x){
           df <- distances[distances$transect==x, ]
           df <- df[order(df$date), ]
           x <- zoo(df$distance_sign, df$date)
           mm <- as.numeric(rollmean(x, ventana_de_promediado, fill = NA))
           df$distance_sign <- mm
           df <- df #%>% slice(1:(n()-1))
           return(df)
       }, simplify=F)
interdist_med <- map(distl_med, interpolate) %>% plyr::ldply() %>% mutate(date = as.Date(date, "%Y-%m-%d"))
distances_med <- plyr::ldply(distl_med) %>% mutate(date = as.Date(date, "%Y-%m-%d"))
```

- Representación de la serie suavizada

```{r}
distances_med %>% 
  ggplot() + theme_bw() + aes(x = date, y = distance_sign) +
  geom_ribbon(data = interdist_med, aes(ymax = pmax(distance_sign, 0), ymin = 0), fill = "sienna3") +
  geom_ribbon(data = interdist_med, aes(ymin = pmin(distance_sign, 0), ymax = 0), fill = "skyblue3") +
  geom_hline(yintercept = 0, color = 'grey') +
  geom_line(colour='black', lwd = 0.5) +
  scale_x_date(date_labels = "%Y", date_breaks = '1 year') +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5), text = element_text(size = 14)) +
  facet_wrap(~transect, ncol = 3)
```

## Pos-2015 (Sentinel 2)

COMO QUE NO HACE FALTA TALI, MEJOL DEJA ESO.

## Referencias

GBIF.org (2023). *What is GBIF?* Retrieved from
<https://www.gbif.org/what-is-gbif>

H3 (2022). *Introduction \| H3*. Retrieved from
<https://h3geo.org/docs>

José Ramón Martínez-Batlle (2022). Estadística zonal multipropósito sobre información geoespacial de República Dominicana, usando Google Earth Engine, Python y R. Versión "Let there be environmental variables (v0.0.0.9000)". Zenodo <https://doi.org/10.5281/zenodo.7367256>
